# 기초

## 시간복잡도

- N 1억 | nlogn 5백만 | N제곱 1만 | N세제곱 500 | 2의 n승 20 | n팩 10

## 아스키

- '0' = 48 , 'A' = 65 , 'a' = 97 | ROT 26 => a-z까지는 13개 이다.
- strlen은 O(N)이라 for 밖에서 줘야한다. | c스타일의 마지막에는 NULL이므로 strlen불가시 for(int i = 0; s[i] ; i++) len++; 로 가능!

# 그래프

- 그래프의 표현 : 인접행렬 | 인접리스트 | 간선 리스트

- 그래프의 탐색 : DFS | BFS

- 연결요소개념 : 잘린 파편 그래프 조각을 연결요소, 컴포넌트라고 한다.

  1.  BFS|DFS 를 통해 컴포넌트 수를 구할 수 있음

- 이분그래프 : A,B 두 그룹으로 노드를 나눔, 그룹안에 간선은 존재하지 않음 1. 탐색을 통해, check값을 1,2 로 번갈아 주면서 나눌 수 있음.
- 싸이클 찾기 : 순열, 반복 수열 등으로 문제를 wrap함, 1차수의 그래프로 보고 1차원 graph를 만든다음, 컴포넌트를 파악하는 문제.!!
- 플러드 필: graph가 배열 형태의 구조(인접행렬 아님!) -> | 1. 갈수있는지check | 2. 범위 check| 3. 방문여부 check 최소 3단계!

# DP

- DP 문제 발상 : 1. Overlapping Subproblem(문제 P는 A1,A2,... 로 같은 구조로 조깨짐.) + 2.Optimal Substructure (답 A는 A1,A2,... An을 통해 구함) -> 메모지에이션

- 풀이방법 : 1. TopDown : 문제를 작은 문제로 나눈다. -> 작은 문제를 푼다. \_> 작은 문젤르 풀었으니 문제를 이제 푼다.
- 풀이방법 : 2. BottomUp : 문제를 크기가 작은 문제부터 차례대로 푼다. -> 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다. -> 큰문제가 풀린다.

- 풀이 순서 : d[i] 를 문장으로 정의 한다 , 변수의 갯수만큼 메모배열 만들기 , d[i] 관한 식을 찾는다 , 탑다운|바텀업 으로 푼다.
