# 기초

## 시간복잡도

- N 1억 | nlogn 5백만 | N제곱 1만 | N세제곱 500 | 2의 n승 20 | n팩 10

## 아스키

- '0' = 48 , 'A' = 65 , 'a' = 97 | ROT 26 => a-z까지는 13개 이다.
- strlen은 O(N)이라 for 밖에서 줘야한다. | c스타일의 마지막에는 NULL이므로 strlen불가시 for(int i = 0; s[i] ; i++) len++; 로 가능!

# 그래프

- 그래프의 표현 : 인접행렬 | 인접리스트 | 간선 리스트

- 그래프의 탐색 : DFS | BFS

- 연결요소개념 : 잘린 파편 그래프 조각을 연결요소, 컴포넌트라고 한다.

  1.  BFS|DFS 를 통해 컴포넌트 수를 구할 수 있음

- 이분그래프 : A,B 두 그룹으로 노드를 나눔, 그룹안에 간선은 존재하지 않음 1. 탐색을 통해, check값을 1,2 로 번갈아 주면서 나눌 수 있음.
- 싸이클 찾기 : 순열, 반복 수열 등으로 문제를 wrap함, 1차수의 그래프로 보고 1차원 graph를 만든다음, 컴포넌트를 파악하는 문제.!!
- 플러드 필: graph가 배열 형태의 구조(인접행렬 아님!) -> | 1. 갈수있는지check | 2. 범위 check| 3. 방문여부 check 최소 3단계!

# DP

- DP 문제 발상 : 1. Overlapping Subproblem(문제 P는 A1,A2,... 로 같은 구조로 조깨짐.) + 2.Optimal Substructure (답 A는 A1,A2,... An을 통해 구함) -> 메모지에이션

- 풀이방법 : 1. TopDown : 문제를 작은 문제로 나눈다. -> 작은 문제를 푼다. \_> 작은 문젤르 풀었으니 문제를 이제 푼다.
- 풀이방법 : 2. BottomUp : 문제를 크기가 작은 문제부터 차례대로 푼다. -> 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다. -> 큰문제가 풀린다.

- 풀이 순서 : d[i] 를 문장으로 정의 한다 , 변수의 갯수만큼 메모배열 만들기 , d[i] 관한 식을 찾는다 , 탑다운|바텀업 으로 푼다.

- 문제 유형 :
- 붕어빵판매하기 : Di 가 Di-1 ~ D0 까지 다 봐야하는 경우.(여기서는 max로 ) Di = max(Di-1+P1,Di-2+P2...)

## DP VS BF 같은 문제 다른 접근법 - 1,2,3 더하기

- 아예 접근 방식 자체가 다르다 (재귀함수 STACK(FUNC) 은 하나의 수단일뿐..)
- BF는 정답조건으로 하나씩 만들어가면서(정답인경우|아닌경우|계속경우) ( 백트래킹 - 재귀 )
- DP는 문제를 작은 문제로 만들고 작은문제간의 식을 세운다. => 바텀업(for문) 또는 탑다운(재귀)으로 해결

```cpp
int go(int sum, int goal)
{
    if (sum == goal)
        return 1;
    if (sum > goal)
        return 0;
    int ans_node = 0;
    for (int i = 1; i <= 3; i++)
    {
        ans_node += go(sum + i, goal);
    }
    return ans_node;
}
```

```cpp

int dp2(int n)
{
    d[1] = 1;
    d[2] = 2;
    d[3] = 4;
    for (int i = 4; i <= n; i++)
    {
        d[i] = d[i - 1] + d[i - 2] + d[i - 3];
    }
    return d[n];
}
```
