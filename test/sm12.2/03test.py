# arr = [[1, 2, 3, 0], [4, 5, 6, 0], [7, 8, 9, 0], [1, 2, 3, 4]]


# parsed = [arr[i][j] for i in range(0, 2) for j in range(0, 4)]
# print(parsed)

from collections import deque
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10 ** 8)

# 대규모 토지 개발
# NN 토지, N은 2,4 ... 32
# 각 칸에는 토지개발 이익이 있음
# 개발로 얻을 수 있는 이익중 최댓값
# 하나의 칸이 남으면 개발 종료 -
# d 2승번째 개발할대 최대 이익

N, ans_max = None, [0]
graph = None


def go(s_x: int, e_x: int, s_y: int, e_y: int, val: int):
    # 남은 개발 구역이 하나인 경우
    if s_x + 1 == e_x and s_y + 1 == e_y:
        ans_max.append(val)
        return
    # 4가지 방향으로 쪼개지는 경우 ( 단 시작점과 끝점의 거리가 2 이상이어야 함 )
    mid_x, mid_y = (s_x + e_x) // 2, (s_y + e_y) // 2

    if (e_x - s_x) >= 2:  # x가 분리되는 경우 ( 거리 2 이상)
        plus_v = max([graph[i][j] for i in range(s_x, mid_x) for j in range(s_y, e_y)])
        go(mid_x, e_x, s_y, e_y, val + plus_v)
        plus_v = max([graph[i][j] for i in range(mid_x, e_x) for j in range(s_y, e_y)])
        go(s_x, mid_x, s_y, e_y, val + plus_v)

    if (e_y - s_y) >= 2:  # y가 분리되는 경우
        plus_v = max([graph[i][j] for i in range(s_x, e_x) for j in range(s_y, mid_y)])
        go(s_x, e_x, mid_y, e_y, val + plus_v)
        plus_v = max([graph[i][j] for i in range(s_x, e_x) for j in range(mid_y, e_y)])
        go(s_x, e_x, s_y, mid_y, val + plus_v)


# 현재 중심 x,y - 범위 dx,dy, 가치 v
def main():
    global graph, N
    N = int(input())  # 4
    graph = []
    for _ in range(N):
        graph.append(list(map(int, input().split())))
    go(0, N, 0, N, 0)
    # print(ans_max)
    print(max(ans_max))


if __name__ == "__main__":
    main()


"""
4
1 3 4 5
6 2 9 9
4 3 10 5
5 2 8 6
>34

2
1 2
3 4
>7

2
1 100000
100000 1
>200000

4
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
>4

8
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
>6


32
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
>10
"""
# DP로 풀릴것같아서 고민하다 BFS완전탐색으로 가려다가 디버깅 실패
